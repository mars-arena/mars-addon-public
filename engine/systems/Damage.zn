library Damage requires Events {
	
	public boolean DebugDmg = false;

	public DamageEvent TempDamage = 0;

	SummativeText TempText = 0;

	trigger DamageTrigger = CreateTrigger();

	integer Index = 0;
	real Amplifier = 0;

	// @const максимальное количество типов cтакающегося урона
	public constant integer MAX_COUNT_TYPE_AMPLIFIERS = 5;

	// @const типы мультипликаторов текста
	public constant integer ATTACK_AMPLIFIER = 1;
	public constant integer SIMPLE_AMPLIFIER = 2;
	public constant integer DAMAGE_MULTIPLIER = 3;
	public constant integer AMPLIFIER_4 = 4;
	public constant integer AMPLIFIER_5 = 5;

	// Событие модификатора уворота
	//
	// AddModifierDodgeChance(real dodgeChance)
	// AddModifierMissChance(real missChance)
	// AddModifierTrueStrikeChance(real trueStrikeChance)
	// GetModifierAttackedUnit() -> unit
	// GetModifierAttackingUnit() -> unit
	// GetModifierDodgeChance() -> real
	// GetModifierMissChance() -> real
	// GetModifierTrueStrikeChance() -> real
	// IsModifierAttack() -> boolean
	// SetModifierDodgeChance(real dodgeChance)
	// SetModifierMissChance(real missChance)
	// SetModifierTrueStrikeChance(real trueStrikeChance)
	public integer EVENT_DODGE_MODIFIER;

	// Событие предществующего модификатора урона
	//
	// GetModifierAttackedUnit() -> unit
	// GetModifierAttackingUnit() -> unit
	// IsModifierAttack() -> boolean
	// IsModifierIgnoreBlock() -> boolean
	// IsModifierMagical() -> boolean
	// IsModifierNoRepeat() -> boolean
	// IsModifierPhysical() -> boolean
	// IsModifierPure() -> boolean
	// IsModifierReflection() -> boolean
	// IsModifierSimulate() -> boolean
	// IsModifierSpecAttack() -> boolean
	//
	// AddModifierPierceRate(real pierceRate)
	// GetModifierPierceRate() -> real
	// SetModifierPierceRate(real pierceRate)
	// SetModifierPierceType(integer pierceType)
	//
	// AddModifierDMGAdd(real dmgAdd)
	// GetModifierDMGAdd() -> real
	// SetModifierDMGAdd(real dmgAdd)
	//
	// AddModifierDMGAmplifier(integer typeAmplifier, real dmgAmplifier)
	// GetModifierDMGAmplifier(integer typeAmplifier) -> real
	// SetModifierDMGAmplifier(integer typeAmplifier, real dmgAmplifier)
	public integer EVENT_PRECEDING_MODIFIER;

	// Событие уникальных модификаторов (работает один из)
	//
	// GetModifierAttackedUnit() -> unit
	// GetModifierAttackingUnit() -> unit
	// IsModifierAttack() -> boolean
	// IsModifierIgnoreBlock() -> boolean
	// IsModifierMagical() -> boolean
	// IsModifierNoRepeat() -> boolean
	// IsModifierPhysical() -> boolean
	// IsModifierPure() -> boolean
	// IsModifierReflection() -> boolean
	// IsModifierSimulate() -> boolean
	// IsModifierSpecAttack() -> boolean
	//
	// AddModifierBash(integer typeId, real bashDamage, real duration)
	// AddModifierCriticalDamage(integer typeId, real criticalDamage) 
	// AddModifierCriticalRate(integer typeId, real criticalRate)
	// GetModifierCriticalType() -> integer
	// PlusModifierCriticalRate(real criticalRate)
	public integer EVENT_UNIQUE_MODIFIER;

	// Событие пост модификатора урона
	//
	// GetModifierAttackedUnit() -> unit
	// GetModifierAttackingUnit() -> unit
	// IsModifierAttack() -> boolean
	// IsModifierCritical() -> boolean
	// IsModifierDodge() -> boolean
	// IsModifierIgnoreBlock() -> boolean
	// IsModifierMagical() -> boolean
	// IsModifierNoRepeat() -> boolean 
	// IsModifierPhysical() -> boolean
	// IsModifierPure() -> boolean
	// IsModifierReflection() -> boolean
	// IsModifierSimulate() -> boolean
	// IsModifierSpecAttack() -> boolean
	//
	// GetBlockedFromAmount(real amount) -> real
	//
	// GetModifierDamageGiven() -> real
	// SetModifierDamageGiven(real dmgGiven)
	//
	// GetModifierDamageTaken() -> real
	// SetModifierDamageTaken(real dmgTaken)
	//
	// GetModifierDamageMax() -> real
	// SetModifierDamageMax(real dmgMax)
	//
	// GetModifierArmorReduction();
	public integer EVENT_POST_MODIFIER_INDEX_DAMAGE;
	public integer EVENT_POST_MODIFIER_INDEX_PERCENT;
	public integer EVENT_POST_MODIFIER_INDEX_AMOUNT;
	public integer EVENT_POST_MODIFIER_INDEX_PASS;

	// Событие любого урона
	//
	// GetDamageAttackedUnit() -> unit
	// GetDamageAttackingUnit() -> unit
	// GetDamageBash() -> real
	// GetDamageBashDuration() -> real
	// GetDamageBlocked() -> real
	// GetDamageGiven() -> real
	// GetDamageIgnoreBlock() -> boolean
	// GetDamageIsAttack() -> boolean
	// GetDamageIsBlocked() -> boolean
	// GetDamageIsCritical() -> boolean
	// GetDamageIsDodge() -> boolean
	// GetDamageIsMagical() -> boolean
	// GetDamageIsNoRepeat() -> boolean 
	// GetDamageIsPhysical() -> boolean
	// GetDamageIsPure() -> boolean
	// GetDamageIsReflection() -> boolean
	// GetDamageIsSimulate() -> boolean
	// GetDamageIsSpecAttack() -> boolean
	// GetDamageLifeAttackedUnit() -> real
	public integer EVENT_DAMAGE;

	// Событие смерти юнита
	//
	// GetDeathKillingUnit() -> unit
	// GetDeathKilledUnit() -> unit
	public integer EVENT_DEATH;

	real DMGAmplifier[MAX_COUNT_TYPE_AMPLIFIERS];

	boolean IgnoreBlock = false;
	boolean IgnoreMiss = false;
	boolean IsAttack = false;
	boolean IsBlocked = false;
	boolean IsCritical = false;
	boolean IsDodge = false;
	boolean IsHide = false;
	boolean IsMagical = false;
	boolean IsManual = false;
	boolean IsNoRepeat = false;
	boolean IsPhys = false;
	boolean IsPure = false;
	boolean IsReflection = false;
	boolean IsRun = false;
	boolean IsSimulate = false;
	boolean IsSpecAttack = false;
	boolean IsTrueStrike = false;
	boolean WithArmor = false;
	boolean WithOrigin = false;
	integer BashType = 0;
	integer CriticalType = 0;
	integer PierceType = 0;
	real ArmorReduction = 0.00;
	real BashDamage = 0.00;
	real BashDuration = 0.00;
	real CritDmg = 0.00;
	real CritRate = 0.00;
	real DMGAdd = 0.00;
	real DMGCaptured = 0;
	real DMGMax = 0;
	real DMGGiven = 0.;
	real DMGBlocked = 0.;
	real DMGOrigin = 0;
	real DMGTaken = 0;
	real DodgeChance = 0;
	real LifeAttackedUnit = 0;
	real MissChance = 0;
	real PierceRate = 0;
	real TrueStrikeChance = 0;
	real UniquePower = 0;
	unit AttackedUnit = null;
	unit AttackingUnit = null;
	unit SourceUnit = null;
	Point2D SourcePosition = 0;

	function ClearDamageEngineGlobals() {
		debug {
			if (IsRun) {
				if (IsManual) Debug("- вручную");
				Error("D1", "Очистка дамаг системы во время работы.");
				Debug("-- " + GetUnitName(AttackingUnit) + "|r -> " + GetUnitName(AttackedUnit) + "|r --");
			}
		}

		ArmorReduction = 0.00;
		AttackedUnit = null;
		AttackingUnit = null;
		SourceUnit = null;
		if (IsSet(SourcePosition)) SourcePosition.destroy();
		SourcePosition = 0;
		BashDamage = 0.00;
		BashDuration = 0.00;
		BashType = 0;
		CritRate = 0.00;
		CritDmg = 0.00;
		CriticalType = 0;
		DMGAdd = 0.00;
		DMGCaptured = 0;
		DMGMax = 0;
		DMGGiven = 0.;
		for (1 <= Index <= MAX_COUNT_TYPE_AMPLIFIERS)
			DMGAmplifier[Index] = 1.0;
		DMGBlocked = 0;
		DMGOrigin = 0;
		DMGTaken = 0;
		DodgeChance = 0;
		IgnoreBlock = false;
		IgnoreMiss = false;
		IsAttack = false;
		IsBlocked = false;
		IsCritical = false;
		IsDodge = false;
		IsHide = false;
		IsMagical = false;
		IsManual = false;
		IsNoRepeat = false;
		IsPhys = false;
		IsPure = false;
		IsReflection = false;
		IsSimulate = false;
		IsSpecAttack = false;
		IsTrueStrike = false;
		LifeAttackedUnit = 0;
		MissChance = 0;
		PierceRate = 0;
		PierceType = 0;
		TrueStrikeChance = 0;
		UniquePower = 0;
		WithArmor = false;
		WithOrigin = false;
		SetIsEvalDamage(false);
	}

	boolean IsRunPass = false;
	boolean IGNORE_BLOCK = false;
	boolean IS_ATTACK = false;
	boolean IS_BLOCKED = false;
	boolean IS_CRITICAL = false;
	boolean IS_DODGE = false;
	boolean IS_MAGICAL = false;
	boolean IS_NO_REPEAT = false;
	boolean IS_PHYS = false;
	boolean IS_PURE = false;
	boolean IS_REFLECTION = false;
	boolean IS_SIMULATE = false;
	boolean IS_SPEC_ATTACK = false;
	real BUSH_DAMAGE = 0;
	real BUSH_DURATION = 0;
	real DMG_GIVEN_GET = 0;
	real DMG_BLOCKED_GET = 0;
	real LIFE_ATTACKED_UNIT = 0;
	unit ATTACKED_UNIT_GET = null;
	unit ATTACKING_UNIT_GET = null;
	unit SOURCE_UNIT = null;
	Point2D SOURCE_POSITION = 0;

	function ClearDamagePassGlobals() {
		debug {
			if (IsRunPass) {
				Error("D2", "Очистка дамаг системы во время работы.");
				Debug("-- " + GetUnitName(ATTACKING_UNIT_GET) + "|r -> " + GetUnitName(ATTACKED_UNIT_GET) + "|r --");
			}
		}

		IsRunPass = false;
		IGNORE_BLOCK = false;
		IS_ATTACK = false;
		IS_BLOCKED = false;
		IS_CRITICAL = false;
		IS_DODGE = false;
		IS_MAGICAL = false;
		IS_NO_REPEAT = false;
		IS_PHYS = false;
		IS_PURE = false;
		IS_REFLECTION = false;
		IS_SIMULATE = false;
		IS_SPEC_ATTACK = false;
		BUSH_DAMAGE = 0;
		BUSH_DURATION = 0;
		DMG_GIVEN_GET = 0;
		DMG_BLOCKED_GET = 0;
		LIFE_ATTACKED_UNIT = 0;
		ATTACKED_UNIT_GET = null;
		ATTACKING_UNIT_GET = null;
		SOURCE_UNIT = null;
		if (IsSet(SOURCE_POSITION)) SOURCE_POSITION.destroy();
		SOURCE_POSITION = 0;
	}

	// Отключает детект урона
	public function DisableDetectDamage() {
		DisableTrigger(DamageTrigger);
	}

	// Включает детект урона
	public function EnableDetectDamage() {
		EnableTrigger(DamageTrigger);
	}

	function DebugModifierDamage() {
		debug DebugEvent
			.a(EVENT_DODGE_MODIFIER)
			.a(EVENT_PRECEDING_MODIFIER)
			.a(EVENT_UNIQUE_MODIFIER)
			.a(EVENT_POST_MODIFIER_INDEX_DAMAGE)
			.a(EVENT_POST_MODIFIER_INDEX_PERCENT)
			.a(EVENT_POST_MODIFIER_INDEX_AMOUNT)
			.a(EVENT_POST_MODIFIER_INDEX_PASS)
		.run();
	}

	function DebugPostDamage() {
		debug DebugEvent
			.a(EVENT_POST_MODIFIER_INDEX_DAMAGE)
			.a(EVENT_POST_MODIFIER_INDEX_PERCENT)
			.a(EVENT_POST_MODIFIER_INDEX_AMOUNT)
			.a(EVENT_POST_MODIFIER_INDEX_PASS)
		.run();
	}

	function DebugUniqueDamage() {
		debug DebugEvent
			.a(EVENT_PRECEDING_MODIFIER)
			.a(EVENT_UNIQUE_MODIFIER)
			.a(EVENT_POST_MODIFIER_INDEX_DAMAGE)
			.a(EVENT_POST_MODIFIER_INDEX_PERCENT)
			.a(EVENT_POST_MODIFIER_INDEX_AMOUNT)
			.a(EVENT_POST_MODIFIER_INDEX_PASS)
		.run();
	}

	public function GetModifierAttackedUnit() -> unit {
		debug DebugModifierDamage();
		return AttackedUnit;
	}

	public function GetModifierAttackingUnit() -> unit {
		debug DebugModifierDamage();
		return AttackingUnit;
	}

	public function GetModifierSourceUnit() -> unit {
		debug DebugModifierDamage();
		return SourceUnit;
	}

	public function GetModifierSourcePosition() -> Point2D {
		debug DebugModifierDamage();
		if (!IsSet(SourcePosition)) SourcePosition = Point2D.createAtWidget(SourceUnit);
		return SourcePosition;
	}

	public function IsModifierIgnoreBlock() -> boolean {
		debug DebugModifierDamage();
		return IgnoreBlock;
	}

	public function IsModifierAttack() -> boolean {
		debug DebugModifierDamage();
		return IsAttack;
	}

	public function IsModifierCritical() -> boolean {
		debug DebugPostDamage();
		return IsCritical;
	}

	public function IsModifierDodge() -> boolean {
		debug DebugPostDamage();
		return IsDodge;
	}

	public function IsModifierMagical() -> boolean {
		debug DebugUniqueDamage();
		return IsMagical;
	}

	public function IsModifierNoRepeat() -> boolean  {
		debug DebugUniqueDamage();
		return IsNoRepeat;
	}

	public function IsModifierPhysical() -> boolean {
		debug DebugUniqueDamage();
		return IsPhys;
	}

	public function IsModifierPure() -> boolean {
		debug DebugUniqueDamage();
		return IsPure;
	}

	public function IsModifierReflection() -> boolean {
		debug DebugUniqueDamage(5);
		return IsReflection;
	}

	public function IsModifierSimulate() -> boolean {
		debug DebugUniqueDamage(6);
		return IsSimulate;
	}

	public function IsModifierSpecAttack() -> boolean {
		debug DebugUniqueDamage(7);
		return IsSpecAttack;
	}

	public function AddModifierDodgeChance(real dodgeChance) {
		debug DebugEvent.a(EVENT_DODGE_MODIFIER).run();
		DodgeChance = RMinBJ((1 - (1 - DodgeChance) * (1 - dodgeChance)), 1.00);
	}

	public function GetModifierDodgeChance() -> real {
		debug DebugEvent.a(EVENT_DODGE_MODIFIER).run();
		return DodgeChance;
	}

	public function SetModifierDodgeChance(real dodgeChance) {
		debug DebugEvent.a(EVENT_DODGE_MODIFIER).run();
		DodgeChance = dodgeChance;
	}
	
	public function AddModifierMissChance(real missChance) {
		debug DebugEvent.a(EVENT_DODGE_MODIFIER).run();
		MissChance = RMinBJ((1 - (1 - MissChance) * (1 - missChance)), 1.00);
	}

	public function GetModifierMissChance() -> real {
		debug DebugEvent.a(EVENT_DODGE_MODIFIER).run();
		return MissChance;
	}

	public function SetModifierMissChance(real missChance) {
		debug DebugEvent.a(EVENT_DODGE_MODIFIER).run();
		MissChance = missChance;
	}
	
	public function AddModifierTrueStrikeChance(real trueStrikeChance) {
		debug DebugEvent.a(EVENT_DODGE_MODIFIER).run();
		TrueStrikeChance = RMinBJ((1 - (1 - TrueStrikeChance) * (1 - trueStrikeChance)), 1.00);
	}

	public function GetModifierTrueStrikeChance() -> real {
		debug DebugEvent.a(EVENT_DODGE_MODIFIER).run();
		return TrueStrikeChance;
	}

	public function SetModifierTrueStrikeChance(real trueStrikeChance) {
		debug DebugEvent.a(EVENT_DODGE_MODIFIER).run();
		TrueStrikeChance = trueStrikeChance;
	}

	public function AddModifierPierceRate(real pierceRate) {
		debug DebugEvent.a(EVENT_PRECEDING_MODIFIER).run();
		PierceRate = RMinBJ((1 - (1 - PierceRate) * (1 - pierceRate)), 1.00);
	}

	public function GetModifierPierceRate() -> real {
		debug DebugEvent.a(EVENT_PRECEDING_MODIFIER).run();
		return PierceRate;
	}

	public function SetModifierPierceRate(real pierceRate) {
		debug DebugEvent.a(EVENT_PRECEDING_MODIFIER).run();
		PierceRate = pierceRate;
	}

	public function SetModifierPierceType(integer pierceType) {
		debug DebugEvent.a(EVENT_PRECEDING_MODIFIER).run();
		PierceType = pierceType;
	}
	
	public function AddModifierDMGAdd(real dmgAdd) {
		debug DebugEvent.a(EVENT_PRECEDING_MODIFIER).run();
		DMGAdd = DMGAdd + dmgAdd;
	}

	public function GetModifierDMGAdd() -> real {
		debug DebugEvent.a(EVENT_PRECEDING_MODIFIER).run();
		return DMGAdd;
	}

	public function SetModifierDMGAdd(real dmgAdd) {
		debug DebugEvent.a(EVENT_PRECEDING_MODIFIER).run();
		DMGAdd = dmgAdd;
	}
	
	public function AddModifierDMGAmplifier(integer typeAmplifier, real dmgAmplifier) {
		debug DebugEvent.a(EVENT_PRECEDING_MODIFIER).run();
		DMGAmplifier[typeAmplifier] = DMGAmplifier[typeAmplifier] + dmgAmplifier;
	}

	public function GetModifierDMGAmplifier(integer typeAmplifier) -> real {
		debug DebugEvent.a(EVENT_PRECEDING_MODIFIER).run();
		return DMGAmplifier[typeAmplifier];
	}

	public function SetModifierDMGAmplifier(integer typeAmplifier, real dmgAmplifier) {
		debug DebugEvent.a(EVENT_PRECEDING_MODIFIER).run();
		DMGAmplifier[typeAmplifier] = dmgAmplifier;
	}

	public function GetModifierCriticalType() -> integer {
		debug DebugEvent.a(EVENT_UNIQUE_MODIFIER).run();
		return CriticalType;
	}

	public function AddModifierCriticalRate(integer typeId, real criticalRate) {
		debug DebugEvent.a(EVENT_UNIQUE_MODIFIER).run();
		if (UniquePower < DMGMax * criticalRate &&
			GetUnitAbilityLevel(GetModifierAttackedUnit(), FORG_IMMUNE_ID) <= 0
		) {
			BashDamage = 0;
			BashDuration = 0;
			BashType = 0;
			CritRate = criticalRate;
			CriticalType = typeId;
			CritDmg = DMGMax * criticalRate;
			UniquePower = DMGMax * criticalRate;
		}
	}

	public function PlusModifierCriticalRate(real criticalRate) {
		debug DebugEvent.a(EVENT_UNIQUE_MODIFIER).run();
		if (CritRate > 0.) {
			BashDamage = 0;
			BashDuration = 0;
			BashType = 0;
			CritDmg = DMGMax * (criticalRate + CritRate);
			UniquePower = DMGMax * (criticalRate + CritRate);
		}
	}

	public function AddModifierCriticalDamage(integer typeId, real criticalDamage) {
		debug DebugEvent.a(EVENT_UNIQUE_MODIFIER).run();
		if (UniquePower < DMGMax + criticalDamage &&
			GetUnitAbilityLevel(GetModifierAttackedUnit(), FORG_IMMUNE_ID) <= 0
		) {
			BashDamage = 0;
			BashDuration = 0;
			BashType = 0;
			CritRate = 0;
			CriticalType = typeId;
			CritDmg = DMGMax + criticalDamage;
			UniquePower = DMGMax + criticalDamage;
		}
	}

	public function AddModifierBash(integer typeId, real bashDamage, real duration) {
		debug DebugEvent.a(EVENT_UNIQUE_MODIFIER).run();
		if (UniquePower < DMGMax + bashDamage * 2 + duration * 200 &&
			!IsUnitIllusion(GetModifierAttackingUnit())
		) {
			BashDamage = bashDamage;
			BashDuration = duration;
			BashType = typeId;
			CritRate = 0;
			CriticalType = 0;
			CritDmg = 0;
			UniquePower = DMGMax + bashDamage * 2 + duration * 200;
		}
	}

	public function GetBlockedFromAmount(real amount) -> real {
		debug DebugPostDamage();
		return amount * (1 - PierceRate);
	}
	
	public function GetModifierDamageGiven() -> real {
		debug DebugPostDamage();
		return DMGGiven;
	}

	public function SetModifierDamageGiven(real dmgGiven) {
		debug DebugPostDamage();
		DMGGiven = dmgGiven;
	}

	public function GetModifierDamageTaken() -> real {
		debug DebugPostDamage();
		return DMGTaken;
	}
	public function SetModifierDamageTaken(real dmgTaken) {
		debug DebugPostDamage();
		DMGTaken = dmgTaken;
	}

	public function GetModifierDamageMax() -> real {
		debug DebugPostDamage();
		return DMGMax;
	}
	public function SetModifierDamageMax(real dmgMax) {
		debug DebugPostDamage();
		DMGMax = dmgMax;
	}

	public function GetModifierArmorReduction() -> real {
		debug DebugPostDamage();
		return ArmorReduction;
	}

	public function GetDamageAttackedUnit() -> unit {
		debug DebugEvent.a(EVENT_DAMAGE).run();
		return ATTACKED_UNIT_GET;
	}

	public function GetDamageAttackingUnit() -> unit {
		debug DebugEvent.a(EVENT_DAMAGE).run();
		return ATTACKING_UNIT_GET;
	}

	public function GetDamageSourceUnit() -> unit {
		debug DebugEvent.a(EVENT_DAMAGE).run();
		return SOURCE_UNIT;
	}

	public function GetDamageSourcePosition() -> Point2D {
		debug DebugEvent.a(EVENT_DAMAGE).run();
		if (!IsSet(SOURCE_POSITION)) SOURCE_POSITION = Point2D.createAtWidget(SOURCE_UNIT);
		return SOURCE_POSITION;
	}

	public function GetDamageBash() -> real {
		debug DebugEvent.a(EVENT_DAMAGE).run();
		return BUSH_DAMAGE;
	}

	public function GetDamageBashDuration() -> real {
		debug DebugEvent.a(EVENT_DAMAGE).run();
		return BUSH_DURATION;
	}

	public function GetDamageBlocked() -> real {
		debug DebugEvent.a(EVENT_DAMAGE).run();
		return DMG_BLOCKED_GET;
	}

	public function GetDamageGiven() -> real {
		debug DebugEvent.a(EVENT_DAMAGE).run();
		return DMG_GIVEN_GET;
	}

	public function GetDamageIgnoreBlock() -> boolean {
		debug DebugEvent.a(EVENT_DAMAGE).run();
		return IGNORE_BLOCK;
	}

	public function GetDamageIsAttack() -> boolean {
		debug DebugEvent.a(EVENT_DAMAGE).run();
		return IS_ATTACK;
	}

	public function GetDamageIsBlocked() -> boolean {
		debug DebugEvent.a(EVENT_DAMAGE).run();
		return IS_BLOCKED;
	}

	public function GetDamageIsCritical() -> boolean {
		debug DebugEvent.a(EVENT_DAMAGE).run();
		return IS_CRITICAL;
	}

	public function GetDamageIsDodge() -> boolean {
		debug DebugEvent.a(EVENT_DAMAGE).run();
		return IS_DODGE;
	}

	public function GetDamageIsMagical() -> boolean {
		debug DebugEvent.a(EVENT_DAMAGE).run();
		return IS_MAGICAL;
	}

	public function GetDamageIsNoRepeat() -> boolean  {
		debug DebugEvent.a(EVENT_DAMAGE).run();
		return IS_NO_REPEAT;
	}

	public function GetDamageIsPhysical() -> boolean {
		debug DebugEvent.a(EVENT_DAMAGE).run();
		return IS_PHYS;
	}

	public function GetDamageIsPure() -> boolean {
		debug DebugEvent.a(EVENT_DAMAGE).run();
		return IS_PURE;
	}

	public function GetDamageIsReflection() -> boolean {
		debug DebugEvent.a(EVENT_DAMAGE).run();
		return IS_REFLECTION;
	}

	public function GetDamageIsSimulate() -> boolean {
		debug DebugEvent.a(EVENT_DAMAGE).run();
		return IS_SIMULATE;
	}

	public function GetDamageIsSpecAttack() -> boolean {
		debug DebugEvent.a(EVENT_DAMAGE).run();
		return IS_SPEC_ATTACK;
	}

	public function GetDamageLifeAttackedUnit() -> real {
		debug DebugEvent.a(EVENT_DAMAGE).run();
		return LIFE_ATTACKED_UNIT;
	}

	public function GetDamageIsRunPass() -> boolean {
		return IsRunPass;
	}

	public struct DamageEvent {
		unit whichUnit;
		unit target;
		unit sourceUnit_a;
		real value;
		Point2D sourcePosition_a;
		attacktype attackType;
		damagetype damageType;
		boolean ignoreBlock_a;
		boolean ignoreMiss_a;
		boolean isAttack;
		boolean isHide;
		boolean isNoRepeat;
		boolean isReflection;
		boolean isSimulate;
		boolean isSpecAttack;
		boolean onTrigger;
		boolean wantDelay;
		boolean withOrigin;

		static method create(unit whichUnit, unit target, real value) -> DamageEvent {
			DamageEvent this = DamageEvent.allocate();
			this.whichUnit = whichUnit;
			this.target = target;
			this.sourceUnit_a = whichUnit;
			this.value = value;
			this.sourcePosition_a = 0;
			this.attackType = ATTACK_TYPE_HERO;
			this.damageType = DAMAGE_TYPE_NORMAL;
			this.ignoreBlock_a = false;
			this.ignoreMiss_a = false;
			this.isAttack = false;
			this.isHide = false;
			this.isNoRepeat = false;
			this.isReflection = false;
			this.isSimulate = false;
			this.isSpecAttack = false;
			this.onTrigger = true;
			this.wantDelay = false;
			this.withOrigin = true;
			return this;
		}

		method sourceUnit(unit sourceUnit) -> DamageEvent {
			this.sourceUnit_a = sourceUnit;
			return this;
		}

		method sourcePosition(real x, real y) -> DamageEvent {
			this.sourcePosition_a = Point2D.createAt(x, y);
			return this;
		}

		method types(attacktype attackType, damagetype damageType) -> DamageEvent {
			this.attackType = attackType;
			this.damageType = damageType;
			return this;
		}

		method magic() -> DamageEvent {
			this.attackType = ATTACK_TYPE_NORMAL;
			this.damageType = DAMAGE_TYPE_MAGIC;
			return this;
		}

		method pure() -> DamageEvent {
			this.attackType = ATTACK_TYPE_CHAOS;
			this.damageType = DAMAGE_TYPE_UNIVERSAL;
			return this;
		}

		method phys() -> DamageEvent {
			this.attackType = ATTACK_TYPE_HERO;
			this.damageType = DAMAGE_TYPE_NORMAL;
			return this;
		}

		method ignoreBlock() -> DamageEvent {
			this.ignoreBlock_a = true;
			return this;
		}

		method ignoreMiss() -> DamageEvent {
			this.ignoreMiss_a = true;
			return this;
		}

		method hide() -> DamageEvent {
			this.isHide = true;
			return this;
		}

		method noRepeat() -> DamageEvent {
			this.isNoRepeat = true;
			return this;
		}

		method reflection() -> DamageEvent {
			this.isReflection = true;
			return this;
		}

		method simulate() -> DamageEvent {
			this.isAttack = true;
			this.isSimulate = true;
			return this;
		}

		method specAttack() -> DamageEvent {
			this.isSpecAttack = true;
			return this;
		}

		method offTrigger() -> DamageEvent {
			this.onTrigger = false;
			return this;
		}

		method delayed() -> DamageEvent {
			this.wantDelay = true;
			return this;
		}

		method run() {
			if (!IsUnitInvulnerable(target) && whichUnit != null && target != null) {
				if (!onTrigger) {
					DisableTrigger(DamageTrigger);
					UnitDamageTarget(whichUnit, target, value, true, false, attackType, damageType, WEAPON_TYPE_WHOKNOWS);
					EnableTrigger(DamageTrigger);
					this.destroy();
				} else {
					if (wantDelay) {
						TempTimer = CreateTimer();
						SaveHandleDataInt(TempTimer, this);
						TimerStart(TempTimer, 0, false, function() {
							DamageEvent this = LoadHandleDataInt(GetExpiredTimer());
							FlushTimer(GetExpiredTimer());
							this.execute();
						});
					} else {
						this.execute();
					}
				}
			} else {
				this.destroy();
			}
		}

		method execute() {
			if (UnitAlive(target)) {
				debug {
					if (IsRun) {
						Debug(" ");
						Error("D1", "Недопустимое внутреннее инициирование ивента урона.");
						Debug("-- " + GetUnitName(whichUnit) + "|r -> " + GetUnitName(target) + "|r --");
					}
				}

				ClearDamageEngineGlobals();

				if (attackType == ATTACK_TYPE_CHAOS && damageType == DAMAGE_TYPE_UNIVERSAL) {
					IsPure = true;
				} else if (damageType == DAMAGE_TYPE_ENHANCED || damageType == DAMAGE_TYPE_MAGIC) {
					IsMagical = true;
				} else if (damageType == DAMAGE_TYPE_NORMAL || damageType == DAMAGE_TYPE_UNIVERSAL) {
					IsPhys = true;
				}

				IsManual = true;
				SourceUnit = sourceUnit_a;
				SourcePosition = sourcePosition_a;
				DMGOrigin = value;
				IgnoreBlock = ignoreBlock_a;
				IgnoreMiss = ignoreMiss_a;
				IsAttack = isAttack;
				IsHide = isHide;
				IsNoRepeat = isNoRepeat;
				IsReflection = isReflection;
				IsSimulate = isSimulate;
				IsSpecAttack = isSpecAttack;
				WithOrigin = withOrigin;
				UnitDamageTarget(whichUnit, target, value, true, false, attackType, damageType, WEAPON_TYPE_WHOKNOWS);

				ClearDamageEngineGlobals();
			}

			this.destroy();
		}

		method destroy() {
			whichUnit = null;
			target = null;
			sourceUnit_a = null;
			attackType = null;
			damageType = null;
			this.deallocate();
		}
	}

	struct DamagePass {
		boolean ignoreBlock;
		boolean isAttack;
		boolean isBlocked;
		boolean isCritical;
		boolean isDodge;
		boolean isMagical;
		boolean isNoRepeat;
		boolean isPhys;
		boolean isPure;
		boolean isReflection;
		boolean isSimulate;
		boolean isSpecAttack;
		real bashDamage;
		real bashDuration;
		real dmgBlocked;
		real dmgGiven;
		real lifeAttackedUnit;
		unit attackedUnit;
		unit attackingUnit;
		unit sourceUnit;
		Point2D sourcePosition;

		static method create() -> DamagePass {
			DamagePass this = DamagePass.allocate();
			attackedUnit = null;
			attackingUnit = null;
			sourceUnit = null;
			sourcePosition = 0;
			bashDamage = 0.0;
			bashDuration = 0.0;
			dmgBlocked = 0.0;
			dmgGiven = 0.0;
			ignoreBlock = false;
			isAttack = false;
			isBlocked = false;
			isCritical = false;
			isDodge = false;
			isMagical = false;
			isNoRepeat = false;
			isPhys = false;
			isPure = false;
			isReflection = false;
			isSimulate = false;
			isSpecAttack = false;
			lifeAttackedUnit = 0.0;
			return this;
		}

		method run() {
			TempTimer = CreateTimer();
			SaveHandleDataInt(TempTimer, this);
			TimerStart(TempTimer, 0, false, function() {
				DamagePass this = LoadHandleDataInt(GetExpiredTimer());
				FlushTimer(GetExpiredTimer());

				ClearDamagePassGlobals();

				IsRunPass = true;

				IGNORE_BLOCK = ignoreBlock;
				IS_ATTACK = isAttack;
				IS_BLOCKED = isBlocked;
				IS_CRITICAL = isCritical;
				IS_DODGE = isDodge;
				IS_MAGICAL = isMagical;
				IS_NO_REPEAT = isNoRepeat;
				IS_PHYS = isPhys;
				IS_PURE = isPure;
				IS_REFLECTION = isReflection;
				IS_SIMULATE = isSimulate;
				IS_SPEC_ATTACK = isSpecAttack;
				BUSH_DAMAGE = bashDamage;
				BUSH_DURATION = bashDuration;
				DMG_GIVEN_GET = dmgGiven;
				DMG_BLOCKED_GET = dmgBlocked;
				LIFE_ATTACKED_UNIT = lifeAttackedUnit;
				ATTACKED_UNIT_GET = attackedUnit;
				ATTACKING_UNIT_GET = attackingUnit;
				SOURCE_UNIT = sourceUnit;
				SOURCE_POSITION = sourcePosition;

				ExecuteEvent(EVENT_DAMAGE);

				IsRunPass = false;

				this.destroy();
			});
		}

		method destroy() {
			ClearDamagePassGlobals();
			attackedUnit = null;
			attackingUnit = null;
			this.deallocate();
		}
	}

	unit KILLING_UNIT_GET = null;
	unit KILLED_UNIT_GET = null;
	public function GetDeathKillingUnit() -> unit {
		debug DebugEvent.a(EVENT_DEATH).run();
		return KILLING_UNIT_GET;
	}
	public function GetDeathKilledUnit() -> unit {
		debug DebugEvent.a(EVENT_DEATH).run();
		return KILLED_UNIT_GET;
	}

	struct DeathEvent {
		unit killingUnit;
		unit killedUnit;

		static method create(unit killingUnit, unit killedUnit) -> DeathEvent {
			DeathEvent this = DeathEvent.allocate();
			this.killingUnit = killingUnit;
			this.killedUnit = killedUnit;
			return this;
		}

		method run() {
			TempTimer = CreateTimer();
			SaveHandleDataInt(TempTimer, this);
			TimerStart(TempTimer, 0, false, function() {
				DeathEvent this = LoadHandleDataInt(GetExpiredTimer());
				FlushTimer(GetExpiredTimer());

				KILLING_UNIT_GET = killingUnit;
				KILLED_UNIT_GET = killedUnit;

				ExecuteEvent(EVENT_DEATH);

				KILLING_UNIT_GET = null;
				KILLED_UNIT_GET = null;

				this.destroy();
			});
		}

		method destroy() {
			killingUnit = null;
			killedUnit = null;
			this.deallocate();
		}
	}

	function IsUnitPhysicallyAttacked(unit AttackedUnit) -> boolean {
		return
			(GetUnitAbilityLevel(AttackedUnit, BUFF_1_ID) > 0) ||
			(GetUnitAbilityLevel(AttackedUnit, BUFF_2_ID) > 0) ||
			(GetUnitAbilityLevel(AttackedUnit, BUFF_S1_ID) > 0) ||
			(GetUnitAbilityLevel(AttackedUnit, BUFF_S2_ID) > 0);
	}
	
	function IsUnitSpecAttacked(unit AttackedUnit) -> boolean {
		return
			(GetUnitAbilityLevel(AttackedUnit, BUFF_S1_ID) > 0) ||
			(GetUnitAbilityLevel(AttackedUnit, BUFF_S2_ID) > 0);
	}

	function DetectArmorReduction() {
		if (!WithArmor) {
			if (WithOrigin) {
				ArmorReduction = 1 - (DMGCaptured / DMGOrigin);
			} else if (IsAttack && !IsPure) {
				if (IsMagical) {
					ArmorReduction = GetUnitSpellReduction(AttackedUnit, AttackingUnit);
				} else {
					ArmorReduction = GetUnitArmorReduction(AttackedUnit, AttackingUnit);
					IsPhys = true;
				}
			} else {
				ArmorReduction = 0;
			}
			WithArmor = true;
		}
	}

	function DetectDMGOrigin() {
		if (!WithOrigin) {
			if (IsAttack && !IsPure) {
				DetectArmorReduction();
				DMGOrigin = DMGCaptured/(1 - ArmorReduction);
			} else {
				DMGOrigin = DMGCaptured;
			}
			WithOrigin = true;
		}
	}
	
	function Actions() {
		DamagePass this;
		unit source = GetEventDamageSource();
		unit target = GetTriggerUnit();
		real value = 0;

		if (IsEvalDamage()) {
			EvalArmor();
			SetIsEvalDamage(false);
			
		} else if (GetUnitTypeId(source) == DUMMY_ATC_ID) {
		
			KillUnit(source);
			NegateDamage(target, GetEventDamage());
			
		} else {
			debug {
				if (IsRun) {
					Debug(" ");
					Error("D0", "Недопустимое внутреннее инициирование системы урона.");
					Debug("-- " + GetUnitName(source) + "|r -> " + GetUnitName(target) + "|r --");
				}
			}


			if (!IsManual) {
				ClearDamageEngineGlobals();
			}

			// ИНИЦИАЛИЗАЦИЯ
			IsRun = true;

			AttackingUnit = source;
			AttackedUnit = target;
			DMGCaptured = GetEventDamage();
			LifeAttackedUnit = GetWidgetLife(AttackedUnit);
			if (SourceUnit == null) SourceUnit = AttackingUnit;

			IsAttack = IsUnitPhysicallyAttacked(AttackedUnit) || IsAttack;
			IsSpecAttack = IsUnitSpecAttacked(AttackedUnit) || IsSpecAttack;
			
			// ДЕБАГ
			debug {
				if (DebugDmg) {
					if (IsAttack && !IsSimulate) {
						Debug("-- " + GetUnitName(AttackingUnit) + "|r -->> " + GetUnitName(AttackedUnit) + "|r HP" + R2S(GetWidgetLife(AttackedUnit)) + "/" + R2S(GetUnitMaxLife(AttackedUnit)) + " --");
					} else if (IsSpecAttack) {
						Debug("-- " + GetUnitName(AttackingUnit) + "|r -->>* " + GetUnitName(AttackedUnit) + "|r HP" + R2S(GetWidgetLife(AttackedUnit)) + "/" + R2S(GetUnitMaxLife(AttackedUnit)) + " --");
					} else if (IsSimulate) {
						Debug("-- " + GetUnitName(AttackingUnit) + "|r -->>/ " + GetUnitName(AttackedUnit) + "|r HP" + R2S(GetWidgetLife(AttackedUnit)) + "/" + R2S(GetUnitMaxLife(AttackedUnit)) + " --");
					} else {
						Debug("-- " + GetUnitName(AttackingUnit) + "|r -> " + GetUnitName(AttackedUnit) + "|r HP" + R2S(GetWidgetLife(AttackedUnit)) + "/" + R2S(GetUnitMaxLife(AttackedUnit)) + " --");
					}
	
					if (SourceUnit != AttackingUnit) {
						Debug("- юнит источник: " + GetUnitName(SourceUnit));
					}
					
					if (IsSet(SourcePosition)) {
						Debug("- точка источник: " + R2S(SourcePosition.x) + " " + R2S(SourcePosition.y));
					}
				}
			}
			
			// УВОРОТ
			if (!IgnoreMiss) {

				// динамический расчет модификаторов уворота
				ExecuteEvent(EVENT_DODGE_MODIFIER);

				// логика уворота
				if ((IsAttack && (GetRandomReal(0, 1) < DodgeChance || GetRandomReal(0, 1) < MissChance))) {
					if (GetRandomReal(0, 1) < TrueStrikeChance) {
						// верный удар
						IsDodge = false;
						IsTrueStrike = true;
						//CreateCustomTextToUnit(AttackedUnit, "|c00ff0303" + "pierce!", 9, 15, 1.2, 0.2, 60., 75., 85., 95., -60);
					} else {
						// юнит увернулся
						IsDodge = true;
						IsTrueStrike = false;
						NegateDamage(AttackedUnit, DMGCaptured);
						CreateCustomTextToUnit(AttackedUnit, "|cffff0303" + "промах", 9, 15, 1.2, 0.2, 60., 75., 85., 95., -60);
						DMGGiven = 0.00;
						DMGTaken = 0.00;
					}      
				} else {
					// юнит не увернулся
					IsDodge = false;
				}
			}

			debug {
				if (DebugDmg && IsDodge) {
					Debug("- промах");
				}
			}

			// получить исходный урон для героев
			if ((IsAttack && !IsSimulate && IsHeroDetectAttack(AttackingUnit))) {
				DetectDMGOrigin();
			}

			debug if (DebugDmg) Debug("- отловленный урон = " + R2S(DMGCaptured));
			
			// ПРЕДШЕСТВУЮЩИЕ МОДИФИКАТОРЫ
			if (!IsDodge && DMGCaptured > 0.0) {
				// TO DO вычислять с отловленного урона а потом делить DMGMax на броню если это нужно

				// динамический расчет предшествующих модификаторов
				ExecuteEvent(EVENT_PRECEDING_MODIFIER);

				DetectDMGOrigin();
				DMGMax = DMGOrigin;

				// ДОПОЛНИТЕЛЬНЫЙ УРОН (уменьшается защитой)
				DMGMax = DMGMax + DMGAdd;

				// динамический расчет уникальных модификаторов
				UniquePower = DMGMax;
				ExecuteEvent(EVENT_UNIQUE_MODIFIER);

				// изменение урона критом
				if (CritDmg > 0) {
					DMGMax = CritDmg;
					IsCritical = true;
				}

				// ИЗМЕНЕНИЕ ВСЕГО УРОНА
				Amplifier = 1;
				for (1 <= Index <= MAX_COUNT_TYPE_AMPLIFIERS)
					Amplifier = Amplifier *  DMGAmplifier[Index];
				
				DMGMax = DMGMax * Amplifier;

				// определяем наносимый урон
				DetectArmorReduction();
				DMGGiven = DMGMax * (1 - (ArmorReduction * (1 - PierceRate)));
				DMGTaken = DMGGiven;

				debug {
					if (DebugDmg) Debug("- атака = " + GetBooleanValue(IsAttack)  + " = " + R2S(DMGOrigin));
					if (DebugDmg && IsMagical) Debug("- магический урон");
					if (DebugDmg && IsPhys) Debug("- физический урон");
					if (DebugDmg && IsPure) Debug("- чистый урон");
					if (DebugDmg && ArmorReduction != 0) Debug("- % снижения урона защитой = " + R2S(ArmorReduction));
					if (DebugDmg && DodgeChance != 0.) Debug("- % уворота  = " + R2S(DodgeChance));
					if (DebugDmg && TrueStrikeChance != 0.) Debug("- % верного удара  = " + R2S(TrueStrikeChance));
					if (DebugDmg && MissChance != 0.) Debug("- % промаха  = " + R2S(MissChance));
					if (DebugDmg && PierceRate != 0.) Debug("- % пронзания  = " + R2S(PierceRate));
					if (DebugDmg && DMGAdd != 0.) Debug("- доп урон (физический)  = " + R2S(DMGAdd));
					if (DebugDmg && Amplifier != 1.) Debug("- амплифаер  = " + R2S(Amplifier));
					if (DebugDmg && DMGMax != 0.) Debug("- максимальный урон  = " + R2S(DMGMax));
					if (DebugDmg && DMGGiven != 0.) Debug("- наносимый урон (до пост модификаторов) = " + R2S(DMGGiven));
					if (DebugDmg && DMGTaken != 0.) Debug("- получаемый урон (до пост модификаторов) = " + R2S(DMGTaken));
				}

			}
			
			// динамический расчет модификаторов урона и пост защиты
			ExecuteEvent(EVENT_POST_MODIFIER_INDEX_DAMAGE);
			DMGGiven = RMaxBJ(DMGGiven, 0.0);
			DMGTaken = RMaxBJ(DMGTaken, 0.0);
			DMGMax = RMaxBJ(DMGMax, 0.0);
			ExecuteEvent(EVENT_POST_MODIFIER_INDEX_PERCENT);
			DMGGiven = RMaxBJ(DMGGiven, 0.0);
			DMGTaken = RMaxBJ(DMGTaken, 0.0);
			DMGMax = RMaxBJ(DMGMax, 0.0);
			ExecuteEvent(EVENT_POST_MODIFIER_INDEX_AMOUNT);
			DMGGiven = RMaxBJ(DMGGiven, 0.0);
			DMGTaken = RMaxBJ(DMGTaken, 0.0);
			DMGMax = RMaxBJ(DMGMax, 0.0);
			ExecuteEvent(EVENT_POST_MODIFIER_INDEX_PASS);
			DMGGiven = RMaxBJ(DMGGiven, 0.0);
			DMGTaken = RMaxBJ(DMGTaken, 0.0);
			DMGMax = RMaxBJ(DMGMax, 0.0);

			// ДЕЙСТВИЯ ПОСЛЕ РАСЧЕТА
			if (!IsDodge && DMGCaptured > 0.0) {
				DMGBlocked = RMaxBJ(DMGGiven - DMGTaken, 0.0);

				debug if (DebugDmg && DMGGiven != 0.) Debug("- наносимый урон (после пост модификаторов) = " + R2S(DMGGiven));
				debug if (DebugDmg && DMGTaken != 0.) Debug("- получаемый урон (после пост модификаторов) = " + R2S(DMGTaken));

				// отменяем наносимый урон
				if (DMGTaken <= 0.00) {
					IsCritical = false;
					IsBlocked = true;
					NegateDamage(AttackedUnit, DMGCaptured);
					DMGBlocked = DMGGiven;
				} else {
					IsBlocked = false;

					// отменяем отловленный урон - получаемый урон
					if (DMGTaken < DMGCaptured) {
						NegateDamage(AttackedUnit, DMGCaptured - DMGTaken);
					}

					// наносим получаемый урон - отловленный
					else if (DMGTaken > DMGCaptured) {
						value = DMGTaken - DMGCaptured;
					}
				}

				// отображаем циферки блока
				if (DMGBlocked > 1) {
					TempText = AddSummativeTextToUnitForPlayer(GetOwningPlayer(AttackedUnit), AttackedUnit, BLOCK_TEXT, DMGBlocked + 0.5, "");
					TempText.showToPlayer(GetOwningPlayer(AttackingUnit));
					if (IsMapDuel())
						TempText.showToObservers();
				}

				// ивент смерти
				if (DMGTaken >= LifeAttackedUnit) {
					DeathEvent.create(AttackingUnit, AttackedUnit).run();
				}
			}

			debug if (DebugDmg && DMGBlocked != 0.) Debug("- заблокировано урона  = " + R2S(DMGBlocked));
			debug if (DebugDmg && IsBlocked) Debug("- блок");
			
			//DMGGiven = RMinBJ(DMGGiven, GetWidgetLife(AttackedUnit));
			
			// ОТОБРАЖЕНИЕ УРОНА
			if (!IsDodge && DMGCaptured > 0.0) {
				
				if (DMGMax > 0.00 && IsCritical) {
					// физический критический урон
					if (!IsMagical && !IsPure) {
						CreateFlyingTextToUnit(AttackedUnit, CRITICAL_PHYS_COLOR + I2S(R2I(DMGMax + 0.5)) + "‼|r", CRITICAL_INIT_SIZE, CRITICAL_BONUS_SIZE, CRITICAL_TIME_LIFE, CRITICAL_TIME_FADE, CRITICAL_OFFSET_Z, CRITICAL_MIN_SPEED, CRITICAL_MAX_SPEED, CRITICAL_MIN_ANGLE, CRITICAL_MAX_ANGLE);
					} else

					// магический критический урон
					if (IsMagical) {
						CreateFlyingTextToUnit(AttackedUnit, CRITICAL_MAGIC_COLOR + I2S(R2I(DMGMax + 0.5)) + "‼|r", CRITICAL_INIT_SIZE, CRITICAL_BONUS_SIZE, CRITICAL_TIME_LIFE, CRITICAL_TIME_FADE, CRITICAL_OFFSET_Z, CRITICAL_MIN_SPEED, CRITICAL_MAX_SPEED, CRITICAL_MIN_ANGLE, CRITICAL_MAX_ANGLE);
					} else

					// чистый критический урон
					if (IsPure) {
						CreateFlyingTextToUnit(AttackedUnit, CRITICAL_PURE_COLOR + I2S(R2I(DMGMax + 0.5)) + "‼|r", CRITICAL_INIT_SIZE, CRITICAL_BONUS_SIZE, CRITICAL_TIME_LIFE, CRITICAL_TIME_FADE, CRITICAL_OFFSET_Z, CRITICAL_MIN_SPEED, CRITICAL_MAX_SPEED, CRITICAL_MIN_ANGLE, CRITICAL_MAX_ANGLE);
					}
				}

				if (GetPlayerController(GetOwningPlayer(AttackingUnit)) == MAP_CONTROL_USER && (FLOATING_DMG_ON_UNITS || IsUnitType(AttackedUnit, UNIT_TYPE_HERO))) {
					if (DMGMax > 0.00 && !IsCritical) {
						// обычный чистый урон
						if (IsPure) {
							TempText = AddSummativeTextToUnitForPlayer(GetOwningPlayer(AttackingUnit), AttackedUnit, REGULAR_TEXT, DMGMax, PURE_DMG_COLOR);
							if (IsMapDuel()) TempText.showToObservers();
						} else

						// обычный магический урон
						if (IsMagical) {
							TempText = AddSummativeTextToUnitForPlayer(GetOwningPlayer(AttackingUnit), AttackedUnit, REGULAR_TEXT, DMGMax, MAGICAL_DMG_COLOR);
							if (IsMapDuel()) TempText.showToObservers();
						}
					}

					// обычный урон
					if (DMGGiven > 0.0) {
						TempText = AddSummativeTextToUnitForPlayer(GetOwningPlayer(AttackingUnit), AttackedUnit, DMG_TEXT, DMGGiven, "");
						if (IsMapDuel()) TempText.showToObservers();
					}
				}
			}

			// СОХРАНЕНИЕ СИЛЫ АТАКИ
			if (IsAttack && !IsSimulate && WithOrigin && DMGOrigin > 0 && IsUnitType(AttackingUnit, UNIT_TYPE_HERO))
				SetHeroAttackValue(AttackingUnit, DMGOrigin); 
			
			// ПЕРЕДАЧА
			this = DamagePass.create();
			this.attackedUnit = AttackedUnit;
			this.attackingUnit = AttackingUnit;
			this.sourceUnit = SourceUnit;
			this.sourcePosition = SourcePosition;
			this.bashDamage = BashDamage;
			this.bashDuration = BashDuration;
			this.dmgBlocked = DMGBlocked;
			this.dmgGiven = DMGGiven;
			this.ignoreBlock = IgnoreBlock;
			this.isAttack = IsAttack;
			this.isBlocked = IsBlocked;
			this.isCritical = IsCritical;
			this.isDodge = IsDodge;
			this.isMagical = IsMagical;
			this.isNoRepeat = IsNoRepeat;
			this.isPhys = IsPhys;
			this.isPure = IsPure;
			this.isReflection = IsReflection;
			this.isSimulate = IsSimulate;
			this.isSpecAttack = IsSpecAttack;
			this.lifeAttackedUnit = LifeAttackedUnit;
	
			this.run();

			IsRun = false;

			source = AttackingUnit;
			target = AttackedUnit;

			if (!IsManual) {
				ClearDamageEngineGlobals();
			}

			debug if (DebugDmg) {
				Debug("------------------------------------------------------------------------------");
			}

			// наносим получаемый урон - отловленный
			if (value > 0.0) {
				DisableTrigger(DamageTrigger);
				UnitDamageTarget(source, target, value, true, false, ATTACK_TYPE_CHAOS, DAMAGE_TYPE_UNIVERSAL, WEAPON_TYPE_WHOKNOWS);
				EnableTrigger(DamageTrigger);
			}
		}

		// удаление баффа отлова урона
		if (IsUnitPhysicallyAttacked(target)) {
			UnitRemoveAbility(target, BUFF_1_ID);
			UnitRemoveAbility(target, BUFF_2_ID);
			UnitRemoveAbility(target, BUFF_S1_ID);
			UnitRemoveAbility(target, BUFF_S2_ID);
		}

		source = null;
		target = null;
	}
 

	function onInit() {
		EVENT_DODGE_MODIFIER = CreateEvent("EVENT_DODGE_MODIFIER");
		EVENT_PRECEDING_MODIFIER = CreateEvent("EVENT_PRECEDING_MODIFIER");
		EVENT_UNIQUE_MODIFIER = CreateEvent("EVENT_UNIQUE_MODIFIER");
		EVENT_POST_MODIFIER_INDEX_DAMAGE = CreateEvent("EVENT_POST_MODIFIER_INDEX_DAMAGE");
		EVENT_POST_MODIFIER_INDEX_PERCENT = CreateEvent("EVENT_POST_MODIFIER_INDEX_PERCENT");
		EVENT_POST_MODIFIER_INDEX_AMOUNT = CreateEvent("EVENT_POST_MODIFIER_INDEX_AMOUNT");
		EVENT_POST_MODIFIER_INDEX_PASS = CreateEvent("EVENT_POST_MODIFIER_INDEX_PASS");
		EVENT_DAMAGE = CreateEvent("EVENT_DAMAGE");
		EVENT_DEATH = CreateEvent("EVENT_DEATH");

		AnyUnitDamagedEvent(DamageTrigger);
		TriggerAddAction(DamageTrigger, function Actions);

		RegisterAction(GetHandleId(EVENT_PLAYER_UNIT_ATTACKED), function() {
			if (GetUnitTypeId(GetAttacker()) == DUMMY_ATC_ID &&
				LoadUnitHandle(HT, GetHandleId(GetAttacker()), UNIT_DUMMY_HID) != GetTriggerUnit()
			) {
				debug Warning("D3", GetUnitName(GetTriggerUnit()) + " дамми-юнит попытался атаковать неизвестную цель " + GetUnitName(GetAttacker()));
				KillUnit(GetAttacker());
			}
		});

	}

}