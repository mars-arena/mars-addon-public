library FloatingText requires TechUtils {

	// @const максимальное количество типов плавающего текста
	constant integer MAX_COUNT_TYPE_TEXTS = 6;

	// @const плавающий текст урона будет работать для юнитов
	public constant boolean FLOATING_DMG_ON_UNITS = true;

	// @const время при котором значение нового текста суммируется с предыдущем (0.25 думаю лучше будет)
	constant real ADD_UP_TIME = 0.3;

	// @const задержка набирания скорости плавающим текстом
	constant real VELOCITY_DELAY = 0.3;

	// @const настройки критического текста
	public constant real CRITICAL_INIT_SIZE = 9.;
	public constant real CRITICAL_BONUS_SIZE = 4.25;
	public constant real CRITICAL_TIME_LIFE = 1.;
	public constant real CRITICAL_TIME_FADE = 0.6;
	public constant real CRITICAL_OFFSET_Z = 90.;
	public constant real CRITICAL_MIN_SPEED = 50.;
	public constant real CRITICAL_MAX_SPEED = 70.;
	public constant real CRITICAL_MIN_ANGLE = 0.;
	public constant real CRITICAL_MAX_ANGLE = 360.;

	// @const цвета урона
	public constant string CRITICAL_STRIKE_COLOR = "|cffff0303";
	public constant string CRITICAL_MAGIC_COLOR = "|cffeb2a74";
	public constant string CRITICAL_PURE_COLOR = "|cffff8420";
	//public constant string CRITICAL_DMG_COLOR ="|cffd33933";
	public constant string PURE_DMG_COLOR = "|cfff5f82b";
	public constant string MAGICAL_DMG_COLOR = "|cffb76bff";

	constant real S2V = 0.071 / 128.;

	// @const типы суммирующего текста
	public constant integer HEAL_TEXT = 1;
	public constant integer MANA_TEXT = 2;
	public constant integer BLOCK_TEXT = 3;
	public constant integer DMG_TEXT = 4;
	public constant integer REGULAR_TEXT = 5;

	string Prefix[MAX_COUNT_TYPE_TEXTS];
	string Postfix[MAX_COUNT_TYPE_TEXTS];
	real VelocityY[MAX_COUNT_TYPE_TEXTS];
	real MaxLifeTime[MAX_COUNT_TYPE_TEXTS];
	real MinSize[MAX_COUNT_TYPE_TEXTS];
	real MaxSize[MAX_COUNT_TYPE_TEXTS];
	real MaxBonusSize[MAX_COUNT_TYPE_TEXTS];
	real MaxBonusValue[MAX_COUNT_TYPE_TEXTS];
	boolean PositionOnOverhead[MAX_COUNT_TYPE_TEXTS];
	real OffsetHeight[MAX_COUNT_TYPE_TEXTS];
	real OffsetX[MAX_COUNT_TYPE_TEXTS];
	real OffsetY[MAX_COUNT_TYPE_TEXTS];

	hashtable HTInternal[MAX_COUNT_TYPE_TEXTS];

	function Save(player owner, unit target, integer textType, SummativeText summativeText) {
		SaveInteger(HTInternal[textType], GetHandleId(owner), GetHandleId(target), summativeText);
	}

	function Remove(player owner, unit target, integer textType) {
		RemoveSavedInteger(HTInternal[textType], GetHandleId(owner), GetHandleId(target));
	}

	function Load(player owner, unit target, integer textType) -> SummativeText {
		return LoadInteger(HTInternal[textType], GetHandleId(owner), GetHandleId(target));
	}

	struct VelocityTextTag {
		texttag tag;
		real velocity;
		real timeLife;
		integer textType;
		boolean destroyOnExpire;

		timer tm;

		static real INTERVAL = 1./32.;

		static method create(integer textType) -> VelocityTextTag {
			VelocityTextTag this = VelocityTextTag.allocate();
			this.tag = CreateTextTag();
			this.velocity = 0;
			this.timeLife = MaxLifeTime[textType];
			this.textType = textType;
			this.destroyOnExpire = false;
			this.tm = CreateTimer();
			SaveHandleDataInt(this.tm, this);
			TimerStart(this.tm, INTERVAL, true, function VelocityTextTag.callback);
			return this;
		}

		method destroy() {
			DestroyTextTag(tag); tag = null;
			FlushTimer(tm); tm = null;
			this.deallocate();
		}

		static method callback() {
			VelocityTextTag this = LoadHandleDataInt(GetExpiredTimer());
			real p = 1 - (timeLife + VELOCITY_DELAY) / MaxLifeTime[textType];
			velocity = VelocityY[textType] * MaxReal(0., p);
			timeLife = timeLife - INTERVAL;
			SetTextTagVelocity(tag, 0, velocity);
			if (timeLife <= 0 && destroyOnExpire) {
				this.destroy();
			}
		}

	}

	public struct SummativeText {
		VelocityTextTag vtag;
		player owner;
		unit target;
		integer textType;

		real value;

		timer tm;

		static integer TotalTexts = 1;
		static integer RemoveIndex = 1;

		static method create(player owner, unit target, integer textType) -> SummativeText {
			SummativeText this;
			SummativeText old;
			if (TotalTexts == 90) {
				dbgT("Remove textag " + I2S(RemoveIndex));
				old = SummativeText.load(RemoveIndex);
				if (IsSet(old)) {
					old.destroy();
				}
				RemoveIndex = (RemoveIndex + 1);
				if (RemoveIndex > 90) {
					RemoveIndex = 1;
				}
			} else {
				TotalTexts = TotalTexts + 1;
			}
			
			this = SummativeText.allocate();
			this.vtag = VelocityTextTag.create(textType);
			this.owner = owner;
			this.target = target;
			this.textType = textType;

			this.value = 0;

			this.tm = CreateTimer();
			SaveHandleDataInt(this.tm, this);
			TimerStart(this.tm, MaxLifeTime[textType], false, function SummativeText.expired);

			Save(owner, target, textType, this);

			return this;
		}

		static method load(integer index) -> SummativeText {
			return index;
		}

		method showValue(real addValue, string prefix) -> SummativeText {
			value += addValue;
			if (TimerGetElapsed(tm) > ADD_UP_TIME) {
				vtag.destroyOnExpire = true; 
				vtag = VelocityTextTag.create(textType);
				value = addValue;
			}
			if (prefix == "")
				prefix = Prefix[textType];
			vtag.timeLife = MaxLifeTime[textType];
			SetTextTagText(vtag.tag, prefix + I2S(R2I(value + 0.5)) + Postfix[textType], TextTagSize2Height(MinReal(MaxSize[textType], MinSize[textType] + MaxBonusSize[textType] * (value / MaxBonusValue[textType]))));
			if (PositionOnOverhead[textType]) 
				SetTextTagPosUnit(vtag.tag, target, OffsetHeight[textType]);
			else 
				SetTextTagPos(vtag.tag, GetUnitX(target) + OffsetX[textType], GetUnitY(target) + OffsetY[textType], OffsetHeight[textType] + MaxReal(GetUnitFlyHeight(target) - 60., 0));
			SetTextTagVelocity(vtag.tag, 0, 0);
			SetTextTagAge(vtag.tag, 0);
			SetTextTagPermanent(vtag.tag, false);
			SetTextTagLifespan(vtag.tag, MaxLifeTime[textType]);
			SetTextTagFadepointBJ(vtag.tag, ADD_UP_TIME);
			SetTextTagVisibility(this.vtag.tag, false);
			if (!IsUnitFogged(target, owner) && IsUnitVisible(target, owner) && GetLocalPlayer() == owner)
				SetTextTagVisibility(this.vtag.tag, true);
			PauseTimer(tm);
			TimerStart(tm, MaxLifeTime[textType], false, function SummativeText.expired);
			return this;
		}

		method showToPlayer(player participant) -> SummativeText {
			if (!IsUnitFogged(target, participant) && IsUnitVisible(target, participant) && GetLocalPlayer() == participant)
				SetTextTagVisibility(this.vtag.tag, true);
			return this;
		}

		method hideToPlayer(player participant) -> SummativeText {
			if (!IsUnitFogged(target, participant) && IsUnitVisible(target, participant) && GetLocalPlayer() == participant)
				SetTextTagVisibility(this.vtag.tag, false);
			return this;
		}

		method showToAll() -> SummativeText {
			SetTextTagVisibility(this.vtag.tag, true);
			return this;
			 
		}

		method showToObservers() -> SummativeText {
			if (IsPlayerInForce(owner, udg_Observers)) {
				SetTextTagVisibility(this.vtag.tag, false);
				return this;
			}

			This = this;
			ForForce(udg_Observers, function() {
				SummativeText this = This;
				if (!IsUnitFogged(target, GetEnumPlayer()) &&
					IsUnitVisible(target, GetEnumPlayer()) &&
					GetLocalPlayer() == GetEnumPlayer()
				) {
					SetTextTagVisibility(this.vtag.tag, true);
				}
			});
			return this;
		}

		method destroy() {
			TotalTexts -= 1;
			Remove(owner, target, textType);
			vtag.destroy();
			owner = null;
			target = null;
			FlushTimer(tm); tm = null;
			this.deallocate();
		}

		static method expired() {
			SummativeText this = LoadHandleDataInt(GetExpiredTimer());
			this.destroy();
		}

	}

	function GetSummativeTextByUnitAndPlayerAndTextType(player owner, unit target, integer textType) -> SummativeText {
		SummativeText summativeText = Load(owner, target, textType);
		
		if (summativeText == 0)
			return SummativeText.create(owner, target, textType);
		
		return summativeText;
	}

	public function AddSummativeTextToUnitForPlayer(
		player owner,
		unit target,
		integer textType,
		real value,
		string prefix
	) -> SummativeText {
		SummativeText summativeText = GetSummativeTextByUnitAndPlayerAndTextType(owner, target, textType);
		summativeText.showValue(value, prefix);
		return summativeText;
	}

	public function ShowSummativeTextToPlayer(SummativeText summativeText, player participant) {
		summativeText.showToPlayer(participant);
	}

	function onInit() {
		Prefix[HEAL_TEXT] = "|cff00ff00+";    // префикс
		Postfix[HEAL_TEXT] = " ♥|r";				// постфикс
		VelocityY[HEAL_TEXT] = 100 * S2V;		// скорость (0..100)
		MaxLifeTime[HEAL_TEXT] = 1.;			// время жизни
		MinSize[HEAL_TEXT] = 9.;				// минимальный размер (изменяется в зависимости от значения value)
		MaxSize[HEAL_TEXT] = 14.;				// максимальный размер
		MaxBonusSize[HEAL_TEXT] = 5.;			// максимальный бонусный размер
		MaxBonusValue[HEAL_TEXT] = 3000.;		// фактор значения
		PositionOnOverhead[HEAL_TEXT] = false;	// показывать выше хпбара
		OffsetHeight[HEAL_TEXT] = 120;			// смещение по высоте
		OffsetX[HEAL_TEXT] = -90;				// смещение по X (не работает с PositionOnOverhead)
		OffsetY[HEAL_TEXT] = 60;				// смещение по Y (не работает с PositionOnOverhead)

		Prefix[MANA_TEXT] = "|cff0080ff+";
		Postfix[MANA_TEXT] = " ▲|r";
		VelocityY[MANA_TEXT] = 100 * S2V;
		MaxLifeTime[MANA_TEXT] = 1.;
		MinSize[MANA_TEXT] = 9.;
		MaxSize[MANA_TEXT] = 14.;
		MaxBonusSize[MANA_TEXT] = 5.;
		MaxBonusValue[MANA_TEXT] = 3000.;
		PositionOnOverhead[MANA_TEXT] = false;
		OffsetHeight[MANA_TEXT] = 120;
		OffsetX[MANA_TEXT] = -90;
		OffsetY[MANA_TEXT] = 0;

		Prefix[BLOCK_TEXT] = "|cffFF8E00-";
		Postfix[BLOCK_TEXT] = "|r";
		VelocityY[BLOCK_TEXT] = -100 * S2V;
		MaxLifeTime[BLOCK_TEXT] = 1.;
		MinSize[BLOCK_TEXT] = 7.;
		MaxSize[BLOCK_TEXT] = 10.;
		MaxBonusSize[BLOCK_TEXT] = 3.;
		MaxBonusValue[BLOCK_TEXT] = 1000.;
		PositionOnOverhead[BLOCK_TEXT] = false;
		OffsetHeight[BLOCK_TEXT] = 0;
		OffsetX[BLOCK_TEXT] = 0;
		OffsetY[BLOCK_TEXT] = 0;

		Prefix[DMG_TEXT] = "";
		Postfix[DMG_TEXT] = "|r";
		VelocityY[DMG_TEXT] = 100 * S2V;
		MaxLifeTime[DMG_TEXT] = 1.;
		MinSize[DMG_TEXT] = 7.;
		MaxSize[DMG_TEXT] = 12.;
		MaxBonusSize[DMG_TEXT] = 5.;
		MaxBonusValue[DMG_TEXT] = 5000.;
		PositionOnOverhead[DMG_TEXT] = true;
		OffsetHeight[DMG_TEXT] = 0;
		OffsetX[DMG_TEXT] = 0;
		OffsetY[DMG_TEXT] = 0;

		Prefix[REGULAR_TEXT] = "";
		Postfix[REGULAR_TEXT] = " ♦|r";
		VelocityY[REGULAR_TEXT] = 200 * S2V;
		MaxLifeTime[REGULAR_TEXT] = 1.;
		MinSize[REGULAR_TEXT] = 8.;
		MaxSize[REGULAR_TEXT] =  14.;
		MaxBonusSize[REGULAR_TEXT] = 5.;
		MaxBonusValue[REGULAR_TEXT] = 10000.;
		PositionOnOverhead[REGULAR_TEXT] = true;
		OffsetHeight[REGULAR_TEXT] = 60;
		OffsetX[REGULAR_TEXT] = 0;
		OffsetY[REGULAR_TEXT] = 0;

		for (1 <= Index <= MAX_COUNT_TYPE_TEXTS)
			HTInternal[Index] = InitHashtable();
	}

}
